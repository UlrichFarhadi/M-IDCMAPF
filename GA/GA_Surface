# Library imports
import sys
import os
import copy
import random
import numpy as np
from typing import List, Tuple, Callable
from tqdm import tqdm
from dask.distributed import Client, LocalCluster
from dask import delayed
from dask import compute
import time
import csv

# Self made imports

# Get the path of the current script
script_dir = os.path.dirname(os.path.abspath(__file__))
# Add the parent directory of the current script to the Python path
parent_dir = os.path.abspath(os.path.join(script_dir, '..'))
sys.path.append(parent_dir) 

from GA.GA_template import GA_template
from Simulator.simulator import Simulator
from IDCMAPF_Tests.tests import *

class GA_Surface(GA_template):
    def __init__(self,
                environment_function,
                env,
                num_best_solutions_to_save: int = 10,
                population_size: int = 20,
                mutation_rate: float = 0.1,
                elitism: int = 3,
                max_num_generations: int = 500,
                interpolation_row_discretize_factor: int = 6,
                interpolation_col_discretize_factor: int = 6,
                default_anchorpoint_value: int = 0.5,

                amount_of_agents = 10,
                mutation_rate_swap = 0.05,
                mutation_rate_point = 0.10,
                agent_type=IDCMAPF_agent,
                delay=0.0001,
                fig_size_factor=20,
                node_size=10,
                linewidth=0.5,
                dpi=40,
                display=False,
                max_timestep=1000) -> None:
        super().__init__(num_best_solutions_to_save, population_size, mutation_rate, elitism, max_num_generations)
        self.fitness_exponent = 3
        self.environment_function = environment_function
        self.best_sumofcosts = 999999999
        self.map = Map_directed()
        self.map.generate_map(env)
        self.env = env
        self.interpolation_row_discretize_factor = interpolation_row_discretize_factor
        self.interpolation_col_discretize_factor = interpolation_col_discretize_factor
        self.default_anchorpoint_value = default_anchorpoint_value

        self.mutation_rate_swap = mutation_rate_swap
        self.mutation_rate_point = mutation_rate_point
        self.amount_of_agents = amount_of_agents
        self.agent_type = agent_type
        self.delay = delay
        self.fig_size_factor = fig_size_factor
        self.node_size = node_size
        self.linewidth = linewidth
        self.dpi = dpi
        self.display = display
        self.max_timestep = max_timestep

    def generate_points(self, default_value=None):
        points = []
        for i in range(self.map.map_height//self.interpolation_row_discretize_factor):
            row_points = []
            for j in range(self.map.map_width//self.interpolation_col_discretize_factor):
                if default_value is None:
                    row_points.append(random.random()) # Value between 0 and 1
                else:       
                    row_points.append(default_value)
            points.append(row_points)
        return points

    def interpolate_points(self, list):



    # Define the problem-specific fitness function
    def fitness(self, chromosome, start_position, target_position):
        cost = 0
        num_env_repetitions = 1
        for i in range(num_env_repetitions):
            cost, span = self.environment_function(chromosome,
                                            start_position,
                                            target_position,
                                            self.env,
                                            amount_of_agents = self.amount_of_agents,
                                            agent_type = self.agent_type,
                                            delay = self.delay,
                                            fig_size_factor = self.fig_size_factor,
                                            node_size = self.node_size,
                                            linewidth = self.linewidth,
                                            dpi = self.dpi,
                                            display = self.display,
                                            max_timestep = self.max_timestep)
        cost = cost / num_env_repetitions
        # if cost < self.best_sumofcosts:
        #     self.best_sumofcosts = cost 

        return (cost**self.fitness_exponent)

    # Define the genetic operators
    def crossover(self, parent1, parent2):
        # Point Crossover
        # Assume that both parents are sequences of the same length
        if len(parent1) != len(parent2):
            raise IndexError("the Parrents are not the same length")
        crossover_point = random.randint(0, len(parent1))
        child = parent1[:crossover_point] + parent2[crossover_point:]
        return child
    
    def single_element_crossover(parent1, parent2, crossover_probability):
        # Single element crossover:
            # EXAMPLE:
            # parent1 = [1, 2, 3, 4, 5]
            # parent2 = [6, 7, 8, 9, 10]
            # # Perform a single element crossover with a probability of 0.5
            # child = single_element_crossover(parent1, parent2, 0.5)
            # print(child)
            # [1, 7, 3, 4, 10]

        if len(parent1) != len(parent2):
            raise IndexError("The parents are not the same length")
        child = []
        for i in range(len(parent1)):
            if random.random() <= crossover_probability:
                child.append(parent2[i])
            else:
                child.append(parent1[i])
        return child

    def mutation_swap(self, chromosome):
        # Swap mutation
        for i in range(len(chromosome)):
            mutate = random.random()
            if mutate < self.mutation_rate_swap:
                idx = random.randint(0, len(chromosome)-1)
                # Swap elements at index i and idx
                chromosome[i], chromosome[idx] = chromosome[idx], chromosome[i]

    def mutation_point(self, chromosome):  
        # Point mutation
        for i in range(len(chromosome)):
            mutate = random.random()
            if mutate < self.mutation_rate_point:
                # Mutate that element of the cromosome (aka give it a new random value between 0 and 1)
                mu, sigma = chromosome[i], 0.1666
                new_weight = np.random.normal(mu, sigma)
                if new_weight > 1:
                    new_weight = 1                   
                elif new_weight < 0:
                    new_weight = 0
                chromosome[i] = new_weight
                #chromosome[i] += random.random()

    def generate_initial_population(self):
        points = self.generate_points(default_value=0.5)
        initial_chromosome = [item for sublist in points for item in sublist] # make the chromosone a list instead of a list of lists
        
        population = []
        for i in range(self.population_size):
            chromosome_copy = copy.deepcopy(initial_chromosome)
            population.append([chromosome_copy, 0.0]) # Append the scores
        return population

        # # Shuffle the chromosome
        # population = []
        # for i in range(self.population_size):  # Append additional shuffled chromosomes
        #     shuffled_chromosome = initial_nonshuffled_chromosome.copy()
        #     random.shuffle(shuffled_chromosome)
        #     population.append([shuffled_chromosome, 0.0]) # [chromosome, initial_predefined_fitness(to be overritten)]
        # return population

    def roulette_wheel_selection(self, population):
        fitness_scores = [individual[1] for individual in population] # population[:][1]
        total_fitness = sum(fitness_scores)
        selection_probs = [score / total_fitness for score in fitness_scores]
        r = random.uniform(0, 1)
        cumulative_prob = 0
        for i in range(len(selection_probs)):
            cumulative_prob += selection_probs[i]
            if cumulative_prob > r:
                return copy.deepcopy(population[i][0])
    
    def generate_new_population(self, population):
        # population = [[chromosome1, fitness1], [chromosome2, fitness2]....]
        new_population = []
        for i in range(self.population_size):
            #parent1 = self.roulette_wheel_selection(population)
            #parent2 = self.roulette_wheel_selection(population)
            #child = self.crossover(parent1, parent2)   # Cannot crossover in a sequence of unique items
            child = self.roulette_wheel_selection(population)
            self.mutation_swap(child)
            self.mutation_point(child)
            new_population.append([child, 0.0]) # [chromosome, cleared fitness score]

        for elite in range(self.elitism):   # If elitism is a number higher than 0
            new_population[elite] = self.list_of_best_solutions[elite]

        return new_population


    def run(self):
        cluster = LocalCluster()
        client = Client(cluster)
        print(f"Link to dask dashboard {client.dashboard_link}")

        # Write in a terminal. dask scheduler
        # Write in another terminal: dask worker <ip from scheduler (connect worker at.. that ip)>
        # Connect another pc using the same as previous step, the reason we also need a worker on the main pc is so that it is also a worker!
        #client = Client("10.126.85.122:8786")


        def sort_by_second_element(item):
            return item[1]
        population = self.generate_initial_population()

        for gen in tqdm(range(self.max_num_generations), desc="Genetic Algorithm Processing...", leave=False):
            #generate_new_start_target_positions()
            start_position, target_position = self.generate_new_start_target_positions()
            # Compute the fitness for each chromosome in the population   
            list_of_cost = []
            #list_of_makespan = []
            for idx, (chromosome, _) in enumerate(population):
                #population[idx][1] = self.fitness(chromosome, start_position, target_position)
                cost = delayed(self.fitness, nout=1)(chromosome, start_position, target_position)  
                list_of_cost.append(cost)
                #list_of_makespan.append(makespan)          

            res = compute(*list_of_cost)
            #res = compute(*list_of_cost, *list_of_makespan)
            #res[:population], res[population:]
            for idx in range(len(population)):
                population[idx][1] = 1000000 / res[idx] # Set the score of each chromosome computed with dask before
    
        
            # Use a lambda sort function Append the self.num_best_solutions_to_save of the chromosomes in the self.list_of_best_solutions array
            self.list_of_best_solutions = sorted(population, key=sort_by_second_element, reverse=True)[:self.num_best_solutions_to_save]
            population = self.generate_new_population(population)

            if gen%1 == 0:    # Print some update information
                #print("\nBest Solution gen: ", gen, " is ", self.list_of_best_solutions[0])
                print("\nBest Solution gen: ", gen)
                sum_of_costs = (1000000 / self.list_of_best_solutions[0][1]) ** (1. / 3)
                print("Best Sum of Costs: ", sum_of_costs)

            if gen%10 == 0:
                self.write_to_csv(self.list_of_best_solutions[0][0], sum_of_costs, "Fluid_chromosome1.csv")
                # print(self.list_of_best_solutions[0])
                
            self.best_sumofcosts = 999999999

            start_position, target_position = self.generate_new_start_target_positions()
            

        
        
    def generate_new_start_target_positions(self):
        start = []
        target = []
        start_positions = copy.deepcopy(self.map.free_nodes)
        for i in range(self.amount_of_agents):
            node_tag = random.choice(start_positions)
            start_positions.remove(node_tag)
            start.append(node_tag)

        target_positions = copy.deepcopy(self.map.free_nodes)
        for i in range(self.amount_of_agents):
            node_tag = random.choice(target_positions)
            target_positions.remove(node_tag)
            target.append(node_tag)
        return start, target
        
    def write_to_csv(self, weight_list, sum_of_costs, filename='output.csv', append=True):
        # If append is True, open the CSV file in append mode
        mode = 'a' if append else 'w'
        
        # Open the CSV file in the specified mode
        with open(filename, mode, newline='') as file:
            writer = csv.writer(file)
            
            # If append is False, write the header row
            if not append:
                writer.writerow(['weight_list', 'sum_of_costs'])
            
            # Loop through the elements of the two lists
            #for i in range(len(int(sum_of_costs))):
                # Get the corresponding elements from the lists
                #soc = sum_of_costs[i]
                
                
                # Append the experiment list (as a string) to the CSV file
            writer.writerow([weight_list, sum_of_costs])